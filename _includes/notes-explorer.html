<div id="notes-explorer" class="notes-explorer">
    <div class="notes-explorer-header">
        <h3 style="margin:0;">Каталог</h3>
        <input id="notes-filter" type="search" placeholder="Фильтр..." aria-label="Фильтр заметок" />
    </div>

    <div class="notes-explorer-section">
        <h4>compact</h4>
        <div id="tree-compact" class="tree"></div>
        <div id="data-compact" hidden>
            {% for f in site.static_files %}{% if f.path contains '/compact/' and f.extname == '.md' %}
            <span data-path="{{ f.path }}"></span>
            {% endif %}{% endfor %}
        </div>

    </div>

    <div class="notes-explorer-section">
        <h4>wide</h4>
        <div id="tree-wide" class="tree"></div>
        <div id="data-wide" hidden>
            {% for f in site.static_files %}{% if f.path contains '/wide/' and f.extname == '.md' %}
            <span data-path="{{ f.path }}"></span>
            {% endif %}{% endfor %}
        </div>
    </div>
</div>

<script>
    (function () {
        const BASE = '{{ site.baseurl | default: "" }}';

        // Enumerate notes from static files
        const COMPACT_STATIC = Array.from(document.querySelectorAll('#data-compact [data-path]')).map(el => el.getAttribute('data-path'));
        const WIDE_PATHS = Array.from(document.querySelectorAll('#data-wide [data-path]')).map(el => el.getAttribute('data-path'));
        const NOTES = {
            compact: (COMPACT_STATIC || []).sort().map(p => ({ path: p })),
            wide: (WIDE_PATHS || []).sort().map(p => ({ path: p }))
        };

        // Build a mapping from topic code (e.g., "1.1") to the compact note path
        function topicCode(str) {
            if (!str) return null;
            // capture first two-level numeric code like 1.1 or 2.5
            const m = String(str).match(/\b(\d+\.\d+)\b/);
            return m ? m[1] : null;
        }
        function basename(p) {
            const i = p.lastIndexOf('/')
            return i >= 0 ? p.slice(i + 1) : p;
        }
        const COMPACT_BY_CODE = new Map();
        for (const p of (COMPACT_STATIC || [])) {
            const title = basename(p).replace(/\.(md|html)$/i, '');
            const code = topicCode(title);
            if (code && !COMPACT_BY_CODE.has(code)) COMPACT_BY_CODE.set(code, normalizePath(p));
        }

        // Sidebar toggle
        const toggleBtn = document.querySelector('.notes-toggle');
        const panel = document.getElementById('notes-explorer');
        if (toggleBtn && panel) {
            toggleBtn.addEventListener('click', () => {
                const open = !panel.hasAttribute('hidden');
                if (open) {
                    panel.setAttribute('hidden', '');
                    toggleBtn.setAttribute('aria-expanded', 'false');
                } else {
                    panel.removeAttribute('hidden');
                    toggleBtn.setAttribute('aria-expanded', 'true');
                }
            });
        }

        // Utilities
        function normalizePath(p) {
            let out = p || '';
            if (BASE && out.startsWith(BASE)) out = out.slice(BASE.length);
            if (!out.startsWith('/')) out = '/' + out;
            return out;
        }

        function titleFromPart(part) {
            return part.replace(/\.(md|html)$/i, '');
        }

        function toTree(items, scope) {
            const root = { dirs: {}, files: [] };
            for (const it of items) {
                const path = it.path; // e.g. /wide/Блок .../1.2/Note.md
                const after = path.split('/' + scope + '/')[1] || '';
                if (!after) continue;
                const parts = after.split('/');
                let node = root;
                for (let i = 0; i < parts.length; i++) {
                    const seg = parts[i];
                    const last = i === parts.length - 1;
                    if (last) {
                        node.files.push({ title: titleFromPart(seg), path });
                    } else {
                        node.dirs[seg] = node.dirs[seg] || { dirs: {}, files: [] };
                        node = node.dirs[seg];
                    }
                }
            }
            return root;
        }

        // Render tree using <details>/<summary>
        function renderTree(container, tree, opts = {}) {
            const isWide = !!opts.isWide;
            container.innerHTML = '';
            const ul = document.createElement('ul');
            ul.style.listStyle = 'none';
            ul.style.paddingLeft = '0.5rem';

            function renderNode(node, parent, depth = 0) {
                // Directories first (sorted)
                const dirNames = Object.keys(node.dirs || {}).sort((a, b) => a.localeCompare(b));
                for (const name of dirNames) {
                    const details = document.createElement('details');
                    const summary = document.createElement('summary');
                    summary.textContent = name;
                    details.appendChild(summary);
                    const inner = document.createElement('div');
                    inner.style.paddingLeft = '0.75rem';
                    details.appendChild(inner);
                    parent.appendChild(details);

                    // If this is a WIDE topic folder and a compact overview exists for its topic code,
                    // insert an overview link at the top of the folder.
                    if (isWide) {
                        const code = topicCode(name);
                        const compactPath = code ? COMPACT_BY_CODE.get(code) : null;
                        if (compactPath) {
                            const li = document.createElement('li');
                            const a = document.createElement('a');
                            a.textContent = 'Кратко (обзор)';
                            a.href = '#' + encodeURI(compactPath);
                            a.dataset.path = compactPath;
                            a.classList.add('vscode-file', `indent-${Math.min(depth + 1, 4)}`);
                            a.addEventListener('click', (e) => {
                                e.preventDefault();
                                selectAndLoad(compactPath);
                            });
                            li.appendChild(a);
                            inner.appendChild(li);
                        }
                    }
                    renderNode(node.dirs[name], inner, depth + 1);
                }
                // Files (sorted)
                const files = (node.files || []).slice().sort((a, b) => a.title.localeCompare(b.title));
                for (const f of files) {
                    const li = document.createElement('li');
                    const a = document.createElement('a');
                    a.textContent = f.title;
                    a.href = '#' + encodeURI(normalizePath(f.path));
                    a.dataset.path = normalizePath(f.path);
                    a.classList.add('vscode-file', `indent-${Math.min(depth, 4)}`);
                    a.addEventListener('click', (e) => {
                        e.preventDefault();
                        selectAndLoad(a.dataset.path);
                    });
                    li.appendChild(a);
                    parent.appendChild(li);
                }
            }

            renderNode(tree, ul, 0);
            container.appendChild(ul);
        }

        // Active state helpers
        let activeLink = null;
        function setActive(path) {
            const container = document.getElementById('notes-explorer');
            if (!container) return;
            if (activeLink) activeLink.classList.remove('active');
            activeLink = container.querySelector(`a[data-path="${CSS.escape(path)}"]`);
            if (activeLink) {
                activeLink.classList.add('active');
                // Ensure parent folders are open
                let el = activeLink;
                while (el && el !== container) {
                    if (el.tagName === 'DETAILS') el.open = true;
                    el = el.parentElement;
                }
            }
        }

        // Filter (simple text filter on titles)
        function filterTrees(q) {
            const ql = (q || '').trim().toLowerCase();
            const sections = document.querySelectorAll('#notes-explorer .notes-explorer-section');
            sections.forEach(sec => {
                // hide/show entire links that don't match
                sec.querySelectorAll('a[data-path]').forEach(a => {
                    const match = a.textContent.toLowerCase().includes(ql);
                    a.parentElement.style.display = match ? '' : 'none';
                });
            });
        }

        // Build and render trees
        const treeCompact = toTree(NOTES.compact, 'compact');
        const treeWide = toTree(NOTES.wide, 'wide');
        renderTree(document.getElementById('tree-compact'), treeCompact, { isWide: false });
        renderTree(document.getElementById('tree-wide'), treeWide, { isWide: true });
        // Auto-open first-level folders
        document.querySelectorAll('#notes-explorer .tree > ul > details').forEach(d => d.open = true);

        // Filter binding
        const filterEl = document.getElementById('notes-filter');
        if (filterEl) {
            filterEl.addEventListener('input', () => filterTrees(filterEl.value));
        }

        // Viewer and loader
        function getViewerEl() {
            return document.getElementById('note-viewer');
        }
        async function fetchText(url) {
            const res = await fetch(encodeURI(url), { cache: 'no-store' });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            return await res.text();
        }

        function rewriteRelativeResources(root, notePath) {
            const relDir = notePath.slice(0, notePath.lastIndexOf('/') + 1);
            const baseDir = (BASE || '') + relDir;
            // images
            root.querySelectorAll('img[src]').forEach(img => {
                const src = img.getAttribute('src');
                if (!src || /^(https?:|data:|\/|#)/i.test(src)) return;
                img.setAttribute('src', baseDir + src);
            });
            // anchors to other local files (optional)
            root.querySelectorAll('a[href]').forEach(a => {
                const href = a.getAttribute('href');
                if (!href || /^(https?:|mailto:|tel:|#|\/)/i.test(href)) return;
                a.setAttribute('href', baseDir + href);
            });
        }

        window.loadNote = async function (path) {
            const viewer = getViewerEl();
            if (!viewer) return;
            const p = normalizePath(path);
            const candidates = [p];
            if (/\.html?$/i.test(p)) candidates.push(p.replace(/\.html?$/i, '.md'));
            else if (/\.md$/i.test(p)) candidates.push(p.replace(/\.md$/i, '.html'));
            let loaded = false;
            for (const cand of candidates) {
                try {
                    const url = (BASE || '') + cand;
                    if (/\.html?$/i.test(cand)) {
                        const pageHtml = await fetchText(url);
                        const doc = new DOMParser().parseFromString(pageHtml, 'text/html');
                        const content = doc.querySelector('.post-content') || doc.body;
                        viewer.innerHTML = content.innerHTML;
                    } else {
                        const md = await fetchText(url);
                        const html = (window.marked && window.marked.parse) ? window.marked.parse(md) : md;
                        viewer.innerHTML = html;
                    }
                    rewriteRelativeResources(viewer, cand);
                    if (window.MathJax) {
                        if (window.MathJax.typesetPromise) {
                            await window.MathJax.typesetPromise([viewer]);
                        } else if (window.MathJax.Hub && window.MathJax.Hub.Queue) {
                            window.MathJax.Hub.Queue(["Typeset", window.MathJax.Hub, viewer]);
                        }
                    }
                    window.scrollTo(0, 0);
                    loaded = true;
                    break;
                } catch (e) {
                    // try next candidate
                }
            }
            if (!loaded) {
                viewer.innerHTML = `<p>Не удалось загрузить заметку: ${p}</p>`;
            }
        };

        function selectAndLoad(p) {
            const path = normalizePath(p);
            setActive(path);
            window.location.hash = '#' + encodeURI(path);
            if (window.loadNote) window.loadNote(path);
        }

        // Initialize after DOM is ready so the viewer exists
        document.addEventListener('DOMContentLoaded', () => {
            if (!location.hash) {
                const first = document.querySelector('#notes-explorer a[data-path]');
                if (first) selectAndLoad(first.dataset.path);
            } else {
                const hashPath = decodeURIComponent(location.hash.slice(1));
                setActive(normalizePath(hashPath));
            }
        });

        // Keep active highlight in sync when hash changes via back/forward
        window.addEventListener('hashchange', () => {
            const hp = decodeURIComponent(location.hash.slice(1));
            if (!hp) return;
            setActive(normalizePath(hp));
        });
    })();
</script>