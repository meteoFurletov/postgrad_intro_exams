<div id="notes-explorer" class="notes-explorer">
    <div class="notes-explorer-header">
        <h3 style="margin:0;">Каталог</h3>
        <input id="notes-filter" type="search" placeholder="Фильтр..." aria-label="Фильтр заметок" />
    </div>

    <div class="notes-explorer-section">
        <h4>Заметки</h4>
        <div id="tree-notes" class="tree"></div>
        <div id="data-notes" hidden>
            {% for f in site.static_files %}{% if f.path contains '/Notes/' and f.extname == '.md' %}
            <span data-path="{{ f.path }}"></span>
            {% endif %}{% endfor %}
        </div>
    </div>
</div>

<script>
    (function () {
        const BASE = '{{ site.baseurl | default: "" }}';

        // Enumerate notes from static files
        const NOTES_PATHS = Array.from(document.querySelectorAll('#data-notes [data-path]')).map(el => el.getAttribute('data-path'));
        const NOTES = (NOTES_PATHS || []).sort().map(p => ({ path: p }));

        // Sidebar toggle
        const toggleBtn = document.querySelector('.notes-toggle');
        const panel = document.getElementById('notes-explorer');
        if (toggleBtn && panel) {
            toggleBtn.addEventListener('click', () => {
                const open = !panel.hasAttribute('hidden');
                if (open) {
                    panel.setAttribute('hidden', '');
                    toggleBtn.setAttribute('aria-expanded', 'false');
                } else {
                    panel.removeAttribute('hidden');
                    toggleBtn.setAttribute('aria-expanded', 'true');
                }
            });
        }

        // Utilities
        function normalizePath(p) {
            let out = p || '';
            if (BASE && out.startsWith(BASE)) out = out.slice(BASE.length);
            if (!out.startsWith('/')) out = '/' + out;
            return out;
        }

        // Natural sorting function for proper numerical order
        function naturalSort(a, b) {
            const aParts = a.split(/(\d+)/);
            const bParts = b.split(/(\d+)/);

            for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {
                const aPart = aParts[i] || '';
                const bPart = bParts[i] || '';

                if (aPart === bPart) continue;

                // Check if both parts are numbers
                const aNum = parseInt(aPart, 10);
                const bNum = parseInt(bPart, 10);

                if (!isNaN(aNum) && !isNaN(bNum)) {
                    return aNum - bNum;
                }

                // Fall back to string comparison
                return aPart.localeCompare(bPart);
            }

            return 0;
        }

        function titleFromPart(part) {
            return part.replace(/\.(md|html)$/i, '');
        }

        function toTree(items) {
            const root = { dirs: {}, files: [] };
            for (const it of items) {
                const path = it.path; // e.g. /Notes/Блок 1/1.1. Theme.md or /Notes/Блок 1/1.1. Theme/subtopic.md
                const after = path.split('/Notes/')[1] || '';
                if (!after) continue;
                const parts = after.split('/');
                let node = root;
                for (let i = 0; i < parts.length; i++) {
                    const seg = parts[i];
                    const last = i === parts.length - 1;
                    if (last) {
                        node.files.push({ title: titleFromPart(seg), path });
                    } else {
                        node.dirs[seg] = node.dirs[seg] || { dirs: {}, files: [] };
                        node = node.dirs[seg];
                    }
                }
            }
            return root;
        }

        // Render tree using <details>/<summary>
        function renderTree(container, tree) {
            container.innerHTML = '';
            const ul = document.createElement('ul');
            ul.style.listStyle = 'none';
            ul.style.paddingLeft = '0.5rem';

            function renderNode(node, parent, depth = 0) {
                // Files first (sorted with natural sorting for proper numerical order)
                const files = (node.files || []).slice().sort((a, b) => naturalSort(a.title, b.title));
                for (const f of files) {
                    const li = document.createElement('li');
                    const a = document.createElement('a');
                    a.textContent = f.title;
                    a.href = '#' + encodeURI(normalizePath(f.path));
                    a.dataset.path = normalizePath(f.path);

                    // Make all files red (theme overview style)
                    a.classList.add('vscode-file', 'theme-overview', `indent-${Math.min(depth, 4)}`);

                    a.addEventListener('click', (e) => {
                        e.preventDefault();
                        selectAndLoad(a.dataset.path);
                    });
                    li.appendChild(a);
                    parent.appendChild(li);
                }

                // Directories after files (sorted with natural sorting)
                const dirNames = Object.keys(node.dirs || {}).sort((a, b) => naturalSort(a, b));
                for (const name of dirNames) {
                    const details = document.createElement('details');
                    const summary = document.createElement('summary');
                    summary.textContent = name;
                    details.appendChild(summary);
                    const inner = document.createElement('div');
                    inner.style.paddingLeft = '0.75rem';
                    details.appendChild(inner);
                    parent.appendChild(details);

                    // Render subdirectories and their files
                    renderNode(node.dirs[name], inner, depth + 1);
                }
            }

            renderNode(tree, ul, 0);
            container.appendChild(ul);
        }

        // Active state helpers
        let activeLink = null;
        function setActive(path) {
            const container = document.getElementById('notes-explorer');
            if (!container) return;
            if (activeLink) activeLink.classList.remove('active');
            activeLink = container.querySelector(`a[data-path="${CSS.escape(path)}"]`);
            if (activeLink) {
                activeLink.classList.add('active');
                // Ensure parent folders are open
                let el = activeLink;
                while (el && el !== container) {
                    if (el.tagName === 'DETAILS') el.open = true;
                    el = el.parentElement;
                }
            }
        }

        // Filter (simple text filter on titles)
        function filterTrees(q) {
            const ql = (q || '').trim().toLowerCase();
            const sections = document.querySelectorAll('#notes-explorer .notes-explorer-section');
            sections.forEach(sec => {
                // hide/show entire links that don't match
                sec.querySelectorAll('a[data-path]').forEach(a => {
                    const match = a.textContent.toLowerCase().includes(ql);
                    a.parentElement.style.display = match ? '' : 'none';
                });
            });
        }

        // Build and render tree
        const treeNotes = toTree(NOTES);
        renderTree(document.getElementById('tree-notes'), treeNotes);

        // Auto-open first-level folders (blocks)
        document.querySelectorAll('#notes-explorer .tree > ul > details').forEach(d => d.open = true);

        // Filter binding
        const filterEl = document.getElementById('notes-filter');
        if (filterEl) {
            filterEl.addEventListener('input', () => filterTrees(filterEl.value));
        }

        // Viewer and loader
        function getViewerEl() {
            return document.getElementById('note-viewer');
        }
        async function fetchText(url) {
            const res = await fetch(encodeURI(url), { cache: 'no-store' });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            return await res.text();
        }

        function rewriteRelativeResources(root, notePath) {
            const relDir = notePath.slice(0, notePath.lastIndexOf('/') + 1);
            const baseDir = (BASE || '') + relDir;
            // images
            root.querySelectorAll('img[src]').forEach(img => {
                const src = img.getAttribute('src');
                if (!src || /^(https?:|data:|\/|#)/i.test(src)) return;
                img.setAttribute('src', baseDir + src);
            });
            // anchors to other local files (optional)
            root.querySelectorAll('a[href]').forEach(a => {
                const href = a.getAttribute('href');
                if (!href || /^(https?:|mailto:|tel:|#|\/)/i.test(href)) return;
                a.setAttribute('href', baseDir + href);
            });
        }

        window.loadNote = async function (path) {
            const viewer = getViewerEl();
            if (!viewer) return;
            const p = normalizePath(path);
            const candidates = [p];
            if (/\.html?$/i.test(p)) candidates.push(p.replace(/\.html?$/i, '.md'));
            else if (/\.md$/i.test(p)) candidates.push(p.replace(/\.md$/i, '.html'));
            let loaded = false;
            for (const cand of candidates) {
                try {
                    const url = (BASE || '') + cand;
                    if (/\.html?$/i.test(cand)) {
                        const pageHtml = await fetchText(url);
                        const doc = new DOMParser().parseFromString(pageHtml, 'text/html');
                        const content = doc.querySelector('.post-content') || doc.body;
                        viewer.innerHTML = content.innerHTML;
                    } else {
                        const md = await fetchText(url);
                        const html = (window.marked && window.marked.parse) ? window.marked.parse(md) : md;
                        viewer.innerHTML = html;
                    }
                    rewriteRelativeResources(viewer, cand);
                    if (window.MathJax) {
                        if (window.MathJax.typesetPromise) {
                            await window.MathJax.typesetPromise([viewer]);
                        } else if (window.MathJax.Hub && window.MathJax.Hub.Queue) {
                            window.MathJax.Hub.Queue(["Typeset", window.MathJax.Hub, viewer]);
                        }
                    }
                    window.scrollTo(0, 0);
                    loaded = true;
                    break;
                } catch (e) {
                    // try next candidate
                }
            }
            if (!loaded) {
                viewer.innerHTML = `<p>Не удалось загрузить заметку: ${p}</p>`;
            }
        };

        function selectAndLoad(p) {
            const path = normalizePath(p);
            setActive(path);
            window.location.hash = '#' + encodeURI(path);
            if (window.loadNote) window.loadNote(path);
        }

        // Initialize after DOM is ready so the viewer exists
        document.addEventListener('DOMContentLoaded', () => {
            if (!location.hash) {
                const first = document.querySelector('#notes-explorer a[data-path]');
                if (first) selectAndLoad(first.dataset.path);
            } else {
                const hashPath = decodeURIComponent(location.hash.slice(1));
                setActive(normalizePath(hashPath));
            }
        });

        // Keep active highlight in sync when hash changes via back/forward
        window.addEventListener('hashchange', () => {
            const hp = decodeURIComponent(location.hash.slice(1));
            if (!hp) return;
            setActive(normalizePath(hp));
        });
    })();
</script>